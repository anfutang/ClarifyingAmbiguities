import os
import json
import logging
from pydantic import BaseModel, Field
from typing import List, Optional

#===== pre-processing ==========
class IsAmbiguousCoT(BaseModel):
    reasoning: str = Field(description="analysis about ambiguity of the input query.")
    ambiguous: bool = Field(description="if the input query is ambiguous.")

#===== stage 1: CQ generation ==========
class CQMultiple(BaseModel):
    clarification_questions: List[str] = Field(description="list of clarification questions generated by LLM.")

class CQCoTMultiple(BaseModel):
    reasoning: str = Field(description="analysis about why the query is ambiguous and how LLM proposes to clarify by asking queries.")
    clarification_questions: List[str] = Field(description="list of clarification questions generated by LLM.")

class RQMultiple(BaseModel):
    reformulated_queries: List[str] = Field(description="list of reformulated queries generated by LLM.")

class RQCoTMultiple(BaseModel):
    reasoning: str = Field(description="analysis about why the query is ambiguous and how LLM proposes to clarify by proposing reformulated queries.")
    reformulated_queries: List[str] = Field(description="list of reformulated queries generated by LLM.")

class CQSingle(BaseModel):
    clarification_question: str = Field(description="list of clarification questions generated by LLM.")

class CQCoTSingle(BaseModel):
    reasoning: str = Field(description="analysis about why the query is ambiguous and how LLM proposes to clarify.")
    clarification_question: str = Field(description="list of clarification questions generated by LLM.")

#===== stage 2: Respond ==========
class Select(BaseModel):
    best_reformulated_query: str = Field(description="the reformulated query selected that is considered to most accurately describe the user's intent.")

class Respond(BaseModel):
    response: str = Field(description="answer to the input clarification question.")

class SelectRespond(BaseModel):
    best_clarification_question: str = Field(description="the clarification question selected that is considered to best meet the user's needs.")
    response: str = Field(description="answer to the selected clarification question.")

#===== stage 3: Reformulation ==========
class Reformulate(BaseModel):
    reformulated_query: str = Field(description="the reformulated query based on the original query and one or several clarification turns.")
